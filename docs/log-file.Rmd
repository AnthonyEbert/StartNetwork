---
title: "Recap"
author: "Anthony Ebert"
date: "25/11/2019"
output: 
  html_document:
    self_contained: false
bibliography: link.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, cache.rebuild = FALSE, autodep = TRUE)
```

```{r libraries, cache = FALSE}
library(StartNetwork)
library(parallel)
library(ggplot2)

sessionInfo()
```

# Tests

## Entropy

We compare entropy computed with the non-parameter estimator `entropy_calc` using samples from the binomial distribution, with the analytic expression for the limit of entropy for the binomial distribution. The same comparison is also made with the Poisson distribution. 

```{r entropy, cache = FALSE}
x <- rbinom(10000, 1000, 0.9)
entropy_calc(x)

1/2 * log(2*pi*exp(1)*1000*0.9*0.1)

lambda <- 50
x <- rpois(1000, lambda)
entropy_calc(x)

k <- 1:100
lambda * (1 - log(lambda)) + exp(-lambda) * sum((lambda^k * lfactorial(k))/factorial(k))
```

## Combinations of degree sequences

### Disjoint edges

```{r disjoint}
disjoint <- choose(choose(seq(15, 7, by = -2),2), 1)
x <- cumsum(log(disjoint[1:5]))

disjoint_dd <- function(x, type = "log", n = 15){
  number_of_graphs_dd(c(rep(0,n - 2*x), rep(1, 2*x)), type = type)
}

y0 <- sapply(1:5, disjoint_dd)
y1 <- sapply(1:5, disjoint_dd, type = "log1")
```

```{r disjoint-plot}
par(pty="s")

plot(x, y0, xlim = c(0, 20), ylim = c(0, 20), asp = 1)
points(x, y1, col = "red")
abline(c(0,1), col = "blue")

plot(x, y0 - x, xlim = c(0, 20), ylim = c(-6, 6))
points(x, y1 - x, col = "red")
```

## Single triangle

```{r single-triangle}
n <- seq(5, 15, by = 2)
#onetriangle <- choose(choose(n,2), 1) * (n - 2)
onetriangle <- choose(n,3)
x <- log(onetriangle[1:6])

triangle_dd <- function(x, type = "log", n = 15){
  number_of_graphs_dd(c(rep(0,x - 3), c(2,2,2)), type = type)
}

y0 <- sapply(n, triangle_dd)
y1 <- sapply(n, triangle_dd, type = "log1")
```

```{r single-triangle-plot}
par(pty="s")

plot(x, y0, xlim = c(0, 10), ylim = c(0, 10), asp = 1)
points(x, y1, col = "red", asp = 1)
abline(c(0,1), col = "blue")

plot(n, y0 - x, xlim = c(0, 15), ylim = c(-60, 60))
points(n, y1 - x, col = "red", asp = 1)
```

## Single reverse triangle

```{r reverse-triangle}
n <- seq(5, 15, by = 2)
#onetriangle <- choose(choose(n,2), 1) * (n - 2)
onetriangle <- choose(n,3)
x <- log(onetriangle[1:6])

triangle_dd <- function(x, type = "log"){
  number_of_graphs_dd(c(rep(x - 1 - 3,x - 3), c(0,0,0)), type = type)
}

y0 <- sapply(n, triangle_dd)
y1 <- sapply(n, triangle_dd, type = "log1")
```

```{r reverse-triangle-plot}
par(pty="s")

plot(x, y0, xlim = c(0, 20), ylim = c(0, 20), asp = 1)
points(x, y1, col = "red", asp = 1)
abline(c(0,1), col = "blue")

plot(n, y0 - x, xlim = c(0, 15), ylim = c(-60, 60))
points(n, y1 - x, col = "red", asp = 1)
```

It seems that the base measure for the sorted degree sequence is more accurately measured for spare graphs than dense graphs. Let's look now at graphs in the middle, regular graphs where the degree is n/2. 

## Regular graph

The analytic expression for the number of regular graphs is reported by @mckay1991asymptotic. 

```{r regular-graph}
n <- seq(6, 20, by = 2)
#onetriangle <- choose(choose(n,2), 1) * (n - 2)
d <- n / 2
lambda <- d / (n - 1)

regulargraphs <- sqrt(2) * exp(0.25) * (lambda^lambda * (1-lambda)^(1-lambda))^choose(n,2) * (choose(n-1,d)^n)
x <- log(regulargraphs)

regular_dd <- function(x, type = "log"){
  number_of_graphs_dd(rep(x/2,x), type = type)
}

y0 <- sapply(n, regular_dd)
y1 <- sapply(n, regular_dd, type = "log1")
```

```{r regular-graph-plot}
par(pty="s")

plot(x, y0, xlim = c(0, 110), ylim = c(0, 110), asp = 1)
points(x, y1, col = "red", asp = 1)
abline(c(0,1), col = "blue")

plot(n, y0 - x, xlim = c(0, 15), ylim = c(-60, 60))
points(n, y1 - x, col = "red", asp = 1)
```

# Examples

```{r metaparameters, cache = TRUE}
n = 15
replicates = 400
```

## Example 1

Mechanistic model: GNP  
Network model: ERGM  
Integral stat: sorted degree sequence  
Likelihood stat: number of edges

```{r example1, cache=TRUE, eval = TRUE}
mech_net_gnp = function(p, n, args){
  args$p = p;
  args$n = n;
  do.call(igraph::sample_gnp, args)
}

mech_args_gnp = list(directed = FALSE)

lstat = function(x){igraph::gsize(x)}

true_value <- 0.1
theta_p <- rep(seq(0.01, 0.2, by = 0.01), 5)
theta_s <- log(true_value/(1 - true_value))

cl <- makeCluster(detectCores())

g <- parSapply(cl, theta_p, KL_net, theta_s = theta_s, n = n, mech_net = mech_net_gnp, mech_args = mech_args_gnp, replicates = replicates, lstat = lstat, sorted = TRUE, type = "log")

stopCluster(cl)
```

```{r example1-processing}
df <- data.frame(parameter = theta_p, KL = g)

ggplot(df) + aes(x = parameter, y = KL, group = parameter) + geom_boxplot() + ggtitle("Example 1") + geom_vline(xintercept = true_value)
```

## Example 2

Mechanistic model: GNP  
Network model: ERGM  
Integral stat: sorted degree sequence  
Likelihood stat: number of edges

```{r example2, cache=TRUE, eval = TRUE}
mech_net_gnp = function(p, n, args){
  args$p = p;
  args$n = n;
  do.call(igraph::sample_gnp, args)
}

mech_args_gnp = list(directed = FALSE)

lstat = function(x){igraph::gsize(x)}

true_value <- 0.9
theta_p <- rep(seq(0.80, 0.99, by = 0.01), 5)
theta_s <- log(true_value/(1 - true_value))

cl <- makeCluster(detectCores())

g <- parSapply(cl, theta_p, KL_net, theta_s = theta_s, n = n, mech_net = mech_net_gnp, mech_args = mech_args_gnp, replicates = replicates, lstat = lstat, sorted = TRUE, type = "log1")

df <- data.frame(parameter = theta_p, KL = g)

ggplot(df) + aes(x = parameter, y = KL, group = parameter) + geom_boxplot() + ggtitle("Example 2") + geom_vline(xintercept = true_value)

stopCluster(cl)
```

# Bibliography



