---
title: "Update"
author: "Anthony Ebert"
date: "04/12/2019"
output: 
  html_document:
    toc: true
    self_contained: false
    code_folding: hide
bibliography: link.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, cache.rebuild = FALSE, autodep = TRUE)
```

```{r libraries, cache = TRUE}
set.seed(1)

library(StartNetwork)
library(parallel)
library(ggplot2)
```

# Tests

Here we test the functions used to estimate entropy and estimate the number of graphs corresponding to a particular sorted degree sequence. We find that the entropy computation is accurate, but estimating the number of graphs corresponding to a sorted degree sequence is more complicated. 

## Entropy

We compare entropy computed with the non-parameter estimator `entropy_calc` using samples from the binomial distribution, with the analytic expression for the limit of entropy for the binomial distribution. The same comparison is also made with the Poisson distribution. 

```{r entropy, cache = TRUE, dependson="libraries"}
x <- rbinom(10000, 1000, 0.9)
entropy_calc(x)

1/2 * log(2*pi*exp(1)*1000*0.9*0.1)

lambda <- 50
x <- rpois(1000, lambda)
entropy_calc(x)

k <- 1:100
lambda * (1 - log(lambda)) + exp(-lambda) * sum((lambda^k * lfactorial(k))/factorial(k))
```

## Combinations of degree sequences

We check whether we are counting the space of graphs correctly. Firstly, we look at graphs where the degrees of the nodes are either zero or one, where the number of nodes with degree one is even. This means that network consists only of disconnected dyads. 

### Disconnected dyads 

```{r disjoint, dependson="libraries"}
disconnected_dyad <- choose(choose(seq(15, 7, by = -2),2), 1)
x <- cumsum(log(disconnected_dyad))

disjoint_dd <- function(x, n = 15){
  number_of_graphs_dd(c(rep(0,n - 2*x), rep(1, 2*x)))
}

y0 <- sapply(1:5, disjoint_dd)
```

```{r disjoint-plot, dependson="disjoint"}
par(pty="s")

plot(x, y0, xlim = c(0, 20), ylim = c(0, 20), asp = 1, xlab = "analytic expression", ylab = "general estimator")
abline(c(0,1), col = "blue")

# plot(x, y0 - x, xlim = c(0, 20), ylim = c(-6, 6))
```

## Single triangle

```{r single-triangle, dependson="libraries"}
n <- seq(5, 15, by = 2)
#onetriangle <- choose(choose(n,2), 1) * (n - 2)
onetriangle <- choose(n,3)
x <- log(onetriangle[1:6])

triangle_dd <- function(x){
  number_of_graphs_dd(c(rep(0,x - 3), c(2,2,2)))
}

y0 <- sapply(n, triangle_dd)
```

```{r single-triangle-plot, dependson="single-triangle"}
par(pty="s")

plot(x, y0, xlim = c(0, 10), ylim = c(0, 10), asp = 1, xlab = "analytic expression", ylab = "general estimator")
abline(c(0,1), col = "blue")

# plot(n, y0 - x, xlim = c(0, 15), ylim = c(-60, 60))
```

## Single reverse triangle

```{r reverse-triangle}
n <- seq(5, 15, by = 2)
#onetriangle <- choose(choose(n,2), 1) * (n - 2)
onetriangle <- choose(n,3)
x <- log(onetriangle[1:6])

triangle_dd <- function(x){
  number_of_graphs_dd(c(rep(x - 1,x - 3), rep(x - 1 - 2, 3)))
}

y0 <- sapply(n, triangle_dd)
```

```{r reverse-triangle-plot}
par(pty="s")

plot(x, y0, xlim = c(0, 20), ylim = c(0, 20), asp = 1, xlab = "analytic expression", ylab = "general estimator")
abline(c(0,1), col = "blue")

# plot(n, y0 - x, xlim = c(0, 15), ylim = c(-60, 60))
```

It seems that the base measure for the sorted degree sequence is more accurately measured for spare graphs than dense graphs. Let's look now at graphs in the middle, regular graphs where the degree is n/2. 

## Regular graph

The analytic expression for the number of regular graphs is reported by @mckay1991asymptotic. 

```{r regular-graph}
n <- seq(7, 21, by = 2)
#onetriangle <- choose(choose(n,2), 1) * (n - 2)
d <- (n - 1) / 2
lambda <- d / (n - 1)

regulargraphs <- sqrt(2) * exp(0.25) * (lambda^lambda * (1-lambda)^(1-lambda))^choose(n,2) * (choose(n-1,d)^n)
x <- log(regulargraphs)

regular_dd <- function(x){
  number_of_graphs_dd(rep(x/2,x))
}

y0 <- sapply(n, regular_dd)
```

```{r regular-graph-plot}
par(pty="s")

plot(x, y0, xlim = c(0, 180), ylim = c(0, 180), asp = 1, xlab = "analytic expression", ylab = "general estimator")
abline(c(0,1), col = "blue")

# plot(n, y0 - x, xlim = c(0, 15), ylim = c(-60, 60))
```

The base measure seems to accurately compute the sorted degree sequence for a regular graph midway between sparse and dense. 

We demonstrate the application of these formulas with a simple example. The mechanistic model is GNP, and the statistical model is an ERGM where the summary statistic is the number of edges. We start with a sparse model where the parameter is 0.1, and then the second example is a dense model where the parameter is 0.9. Finally in example 3, we fix the expression so that it is more accurate for dense graphs. 

# Examples

```{r metaparameters, cache = TRUE}
n = 15
replicates = 400

mech_net_gnp = purrr::partial(igraph::sample_gnp, n = !!n, ... = , directed = FALSE, loops = FALSE)
```

## Example 1

Mechanistic model: Erdös-Renyi (target)  
Statistical model: ERGM  
Integral stat: sorted degree sequence  
Likelihood stat: number of edges

```{r example1, cache=TRUE, eval = TRUE, dependson=c("libraries", "metaparameters")}
true_value <- 0.1
theta_p <- rep(seq(0.01, 0.2, by = 0.01), 5)
theta_s <- log(true_value/(1 - true_value))

cl <- parallel::makeCluster(parallel::detectCores())

g <- parallel::parSapply(cl, theta_p, StartNetwork::KL_net, theta_s = theta_s, replicates = replicates, sorted = TRUE, mech_net = mech_net_gnp, lstat = igraph::gsize)

parallel::stopCluster(cl)
```

```{r example1-plot, eval = TRUE, dependson = "example1"}
library(ggplot2)

df <- data.frame(parameter = theta_p, KL = g)

ggplot(df) + aes(x = parameter, y = KL, group = parameter) + geom_boxplot() + ggtitle("Example 1") + geom_vline(xintercept = true_value)
```

## Example 2

Mechanistic model: Erdös-Renyi (target)  
Statistical model: ERGM  
Integral stat: sorted degree sequence  
Likelihood stat: number of edges

```{r example2, cache=TRUE, eval = TRUE, dependson=c("libraries", "metaparameters")}
true_value <- 0.9
theta_p <- rep(seq(0.80, 0.99, by = 0.01), 5)
theta_s <- log(true_value/(1 - true_value))

cl <- parallel::makeCluster(parallel::detectCores())

g <- parallel::parSapply(cl, theta_p, StartNetwork::KL_net, theta_s = theta_s, replicates = replicates, sorted = TRUE, mech_net = mech_net_gnp, lstat = igraph::gsize)

parallel::stopCluster(cl)
```

```{r example2-plot, dependson = "example2", eval = TRUE}
df <- data.frame(parameter = theta_p, KL = g)

ggplot(df) + aes(x = parameter, y = KL, group = parameter) + geom_boxplot() + ggtitle("Example 2") + geom_vline(xintercept = true_value)
```

## Example 3

Mechanistic model: Erdös-Renyi (target)  
Statistical model: ERGM  
Integral stat: sorted degree sequence  
Likelihood stat: number of edges

```{r example3, cache=TRUE, eval = TRUE, dependson=c("libraries", "metaparameters")}
true_value <- 0.5
theta_p <- rep(seq(0.3, 0.7, by = 0.01), 5)
theta_s <- log(true_value/(1 - true_value))

cl <- parallel::makeCluster(parallel::detectCores())

g <- parallel::parSapply(cl, theta_p, StartNetwork::KL_net, theta_s = theta_s, replicates = replicates, sorted = TRUE, mech_net = mech_net_gnp, lstat = igraph::gsize, mirror = FALSE)

parallel::stopCluster(cl)
```

```{r example3-plot, dependson = "example2", eval = TRUE}
df <- data.frame(parameter = theta_p, KL = g)

ggplot(df) + aes(x = parameter, y = KL, group = parameter) + geom_boxplot() + ggtitle("Example 3") + geom_vline(xintercept = true_value)
```

Since we have found the space of dense graphs is counted inaccurately when the equation of @bianconi2009entropy is naively applied, we map the space of dense graphs to the space of sparse graphs. In other words, we perform this simple conversion on the degree sequence:
$$
d^* = n - d - 1
$$


## Example 4

Mechanistic model: Erdös-Renyi (target)  
Statistical model: ERGM  
Integral stat: sorted degree sequence  
Likelihood stat: number of edges

```{r example4, cache=TRUE, eval = TRUE}
true_value <- 0.9
theta_p <- rep(seq(0.80, 0.99, by = 0.01), 5)
theta_s <- log(true_value/(1 - true_value))

cl <- parallel::makeCluster(parallel::detectCores())

g <- parallel::parSapply(cl, theta_p, StartNetwork::KL_net, theta_s = theta_s, replicates = replicates, sorted = TRUE, mech_net = mech_net_gnp, lstat = igraph::gsize, mirror = TRUE)

parallel::stopCluster(cl)
```

```{r example4-plot, eval = TRUE}
df <- data.frame(parameter = theta_p, KL = g)

ggplot(df) + aes(x = parameter, y = KL, group = parameter) + geom_boxplot() + ggtitle("Example 4") + geom_vline(xintercept = true_value)
```

## Example 5

Mechanistic model: Erdös-Renyi (target)  
Statistical model: ERGM  
Integral stat: sorted degree sequence  
Likelihood stat: number of edges

```{r example5, cache=TRUE, eval = TRUE}
true_value <- 0.5
theta_p <- rep(seq(0.3, 0.7, by = 0.01), 5)
theta_s <- log(true_value/(1 - true_value))

cl <- parallel::makeCluster(parallel::detectCores())

g <- parallel::parSapply(cl, theta_p, StartNetwork::KL_net, theta_s = theta_s, replicates = replicates, sorted = TRUE, mech_net = mech_net_gnp, lstat = igraph::gsize, mirror = TRUE)

parallel::stopCluster(cl)
```

```{r example5-plot, eval = TRUE}
df <- data.frame(parameter = theta_p, KL = g)

ggplot(df) + aes(x = parameter, y = KL, group = parameter) + geom_boxplot() + ggtitle("Example 5") + geom_vline(xintercept = true_value)
```

We have successfully retrieved the parameter for a dense graph. To check

## Single reverse triangle (mirrored degree sequence)

```{r reverse-triangle2}
n <- seq(5, 15, by = 2)
#onetriangle <- choose(choose(n,2), 1) * (n - 2)
onetriangle <- choose(n,3)
x <- log(onetriangle[1:6])

triangle_dd <- function(x){
  number_of_graphs_dd(c(rep(x - 1,x - 3), rep(x - 1 - 2, 3)), mirror = TRUE)
}

ym <- sapply(n, triangle_dd)
```

```{r reverse-triangle2-plot}
par(pty="s")

plot(x, ym, xlim = c(0, 20), ylim = c(0, 20), asp = 1, xlab = "analytic expression", ylab = "general estimator")
abline(c(0,1), col = "blue")
```

# ERGM as mechanistic models

## Example 6

Mechanistic model: ERGM (target)  
Statistical model: ERGM  
Integral stat: sorted degree sequence  
Likelihood stat: number of edges
```{r example6, cache=TRUE, eval = TRUE}
n <- 15

mech_net_ergm <- purrr::partial(mech_net_ergm_n, n = !!n)

true_value <- 0.1
theta_p <- rep(seq(0.01, 0.2, by = 0.01), 5)
theta_s <- log(true_value/(1 - true_value))

cl <- parallel::makeCluster(parallel::detectCores())

g <- parallel::parSapply(cl, theta_p, StartNetwork::KL_net, theta_s = theta_s, replicates = replicates, sorted = TRUE, mech_net = mech_net_ergm, lstat = igraph::gsize)

parallel::stopCluster(cl)
```

```{r example6-plot, eval = TRUE}
df <- data.frame(parameter = theta_p, KL = g)

ggplot(df) + aes(x = parameter, y = KL, group = parameter) + geom_boxplot() + ggtitle("Example 6") + geom_vline(xintercept = true_value)
```

## Example 7

Mechanistic model: ERGM (target)  
Statistical model: ERGM  
Integral stat: sorted degree sequence  
Likelihood stat: number of edges

```{r example7, cache=TRUE, eval = TRUE}
n <- 15

mech_net_ergm <- purrr::partial(mech_net_ergm_n, n = !!n)

true_value <- 0.9
theta_p <- rep(seq(0.80, 0.99, by = 0.01), 5)
theta_s <- log(true_value/(1 - true_value))

cl <- parallel::makeCluster(parallel::detectCores())

g <- parallel::parSapply(cl, theta_p, StartNetwork::KL_net, theta_s = theta_s, replicates = replicates, sorted = TRUE, mech_net = mech_net_ergm, lstat = igraph::gsize, mirror = TRUE)

parallel::stopCluster(cl)
```

```{r example7-plot, eval = TRUE}
df <- data.frame(parameter = theta_p, KL = g)

ggplot(df) + aes(x = parameter, y = KL, group = parameter) + geom_boxplot() + ggtitle("Example 7") + geom_vline(xintercept = true_value)
```

## Example 8

Mechanistic model: ERGM (target)  
Statistical model: ERGM  
Integral stat: sorted degree sequence  
Likelihood stat: number of edges

```{r example8, eval = TRUE}
n <- 15

mech_net_ergm <- purrr::partial(mech_net_ergm_n, n = !!n)

true_value <- 0.5
theta_p <- rep(seq(0.3, 0.7, by = 0.01), 5)
theta_s <- log(true_value/(1 - true_value))

cl <- parallel::makeCluster(parallel::detectCores())

g <- parallel::parSapply(cl, theta_p, StartNetwork::KL_net, theta_s = theta_s, replicates = replicates, sorted = TRUE, mech_net = mech_net_ergm, lstat = igraph::gsize, mirror = TRUE)

parallel::stopCluster(cl)
```

```{r example8-plot, eval = TRUE}
df <- data.frame(parameter = theta_p, KL = g)

ggplot(df) + aes(x = parameter, y = KL, group = parameter) + geom_boxplot() + ggtitle("Example 8") + geom_vline(xintercept = true_value)
```

```{r}
sessionInfo()
```

# Bibliography



